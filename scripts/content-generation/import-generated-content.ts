/**
 * Import Generated Content to Database
 *
 * Imports all content generated by Claude Opus 4.5:
 * - 96 piece introductions (48 Book I + 48 Book II)
 * - 63 feature definitions (Harmony, Counterpoint, Fugue, Form)
 * - 30 curriculum lessons (Domain 1, 2, 3)
 * - BWV 846 measure commentary (62 measures)
 */

import { PrismaClient, FeatureCategory } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';

const prisma = new PrismaClient();

interface PieceIntroduction {
  bwv: number;
  book: number;
  number: number;
  type: string;
  key: string;
  voices?: number;
  introduction: {
    opening_hook: string;
    character: string;
    notable_features: string[];
    listening_focus: string;
    technical_overview: string;
    historical_context: string;
  };
  metadata: {
    difficulty: number;
    study_time_hours: number;
    prerequisites: string[];
    concepts_introduced: string[];
  };
}

interface FeatureDefinition {
  id: string;
  name: string;
  category: string;
  definitions: {
    brief: string;
    standard: string;
    detailed: string;
  };
  listening_guidance: string;
  visual_markers: string;
  common_contexts: string;
  difficulty_level: number;
  prerequisites: string[];
  keywords: string[];
  wtc_examples: { bwv: number; type: string; measures: string; description: string }[];
}

interface GeneratedLesson {
  id: string;
  title: string;
  domain: string;
  order: number;
  estimated_minutes: number;
  learning_objectives: string[];
  prerequisites: string[];
  content: {
    introduction: string;
    explanation: string;
    guided_example?: any;
    additional_examples?: any[];
    summary: string;
  };
  exercises: string[];
  related_features: string[];
  narration_text: string;
}

const CONTENT_DIR = path.join(process.cwd(), 'content');

async function readJsonFile<T>(filePath: string): Promise<T | null> {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(content) as T;
  } catch (error) {
    console.warn(`Could not read ${filePath}: ${(error as Error).message}`);
    return null;
  }
}

async function importPieceIntroductions() {
  console.log('üìö Importing piece introductions...');

  const book1 = await readJsonFile<{ pieces: PieceIntroduction[] }>(
    path.join(CONTENT_DIR, 'pieces', 'book1-introductions.json')
  );
  const book2 = await readJsonFile<{ pieces: PieceIntroduction[] }>(
    path.join(CONTENT_DIR, 'pieces', 'book2-introductions.json')
  );

  const allPieces = [...(book1?.pieces || []), ...(book2?.pieces || [])];
  let updated = 0;

  for (const piece of allPieces) {
    try {
      // Find existing piece by BWV and type
      const existing = await prisma.piece.findFirst({
        where: {
          bwvNumber: piece.bwv,
          type: piece.type.toUpperCase() === 'FUGUE' ? 'FUGUE' : 'PRELUDE',
        },
      });

      if (existing) {
        await prisma.piece.update({
          where: { id: existing.id },
          data: {
            metadata: {
              introduction: piece.introduction,
              studyInfo: piece.metadata,
              voiceCount: piece.voices,
            },
          },
        });
        updated++;
      }
    } catch (error) {
      console.warn(`Failed to update BWV ${piece.bwv}: ${(error as Error).message}`);
    }
  }

  console.log(`‚úì Updated ${updated} piece introductions`);
}

async function importFeatures() {
  console.log('üéµ Importing feature definitions...');

  const featureFiles = [
    { file: 'harmony-features.json', category: 'HARMONY' },
    { file: 'counterpoint-features.json', category: 'COUNTERPOINT' },
    { file: 'fugue-features.json', category: 'FUGUE' },
    { file: 'form-features.json', category: 'FORM' },
  ];

  let created = 0;
  let updated = 0;

  for (const { file, category } of featureFiles) {
    const data = await readJsonFile<{ features: FeatureDefinition[] }>(
      path.join(CONTENT_DIR, 'features', file)
    );

    if (!data?.features) continue;

    for (const feature of data.features) {
      try {
        const existing = await prisma.feature.findUnique({
          where: { slug: feature.id },
        });

        const featureData = {
          name: feature.name,
          slug: feature.id,
          category: category as FeatureCategory,
          description: feature.definitions.standard,
          explanationBeginner: feature.definitions.brief,
          explanationIntermediate: feature.definitions.standard,
          explanationAdvanced: feature.definitions.detailed,
          difficultyLevel: feature.difficulty_level,
          searchKeywords: feature.keywords,
        };

        if (existing) {
          await prisma.feature.update({
            where: { slug: feature.id },
            data: featureData,
          });
          updated++;
        } else {
          await prisma.feature.create({
            data: featureData,
          });
          created++;
        }
      } catch (error) {
        console.warn(`Failed to upsert feature ${feature.id}: ${(error as Error).message}`);
      }
    }
  }

  console.log(`‚úì Created ${created} features, updated ${updated} features`);
}

async function importCurriculumLessons() {
  console.log('üìñ Importing curriculum lessons...');

  const lessonFiles = [
    { file: 'domain1-harmony-lessons.json', domainName: 'Harmonic Fundamentals' },
    { file: 'domain2-voiceleading-lessons.json', domainName: 'Voice Leading' },
    { file: 'domain3-fugue-lessons.json', domainName: 'Fugal Technique' },
  ];

  let created = 0;

  for (const { file, domainName } of lessonFiles) {
    const data = await readJsonFile<{ lessons: GeneratedLesson[] }>(
      path.join(CONTENT_DIR, 'curriculum', file)
    );

    if (!data?.lessons) continue;

    // Ensure domain exists
    let domain = await prisma.domain.findFirst({
      where: { name: domainName },
    });

    if (!domain) {
      domain = await prisma.domain.create({
        data: {
          name: domainName,
          description: `Study of ${domainName.toLowerCase()} principles in Bach's Well-Tempered Clavier`,
          orderIndex: lessonFiles.indexOf({ file, domainName }) + 1,
        },
      });
    }

    // Create unit for these lessons
    let unit = await prisma.unit.findFirst({
      where: {
        domainId: domain.id,
        name: 'Core Concepts',
      },
    });

    if (!unit) {
      unit = await prisma.unit.create({
        data: {
          domainId: domain.id,
          name: 'Core Concepts',
          description: `Essential ${domainName.toLowerCase()} concepts`,
          orderIndex: 1,
        },
      });
    }

    // Create module for these lessons
    let module = await prisma.module.findFirst({
      where: {
        unitId: unit.id,
        name: domainName,
      },
    });

    if (!module) {
      module = await prisma.module.create({
        data: {
          unitId: unit.id,
          name: domainName,
          description: `Comprehensive ${domainName.toLowerCase()} curriculum`,
          orderIndex: 1,
          estimatedDurationMinutes: data.lessons.reduce((sum, l) => sum + l.estimated_minutes, 0),
        },
      });
    }

    // Import lessons
    for (const lesson of data.lessons) {
      try {
        const existing = await prisma.lesson.findFirst({
          where: {
            moduleId: module.id,
            name: lesson.title,
          },
        });

        const lessonData = {
          moduleId: module.id,
          name: lesson.title,
          description: lesson.content.introduction.substring(0, 500),
          orderIndex: lesson.order,
          sections: {
            introduction: lesson.content.introduction,
            explanation: lesson.content.explanation,
            guidedExample: lesson.content.guided_example,
            additionalExamples: lesson.content.additional_examples,
            summary: lesson.content.summary,
            exercises: lesson.exercises,
            learningObjectives: lesson.learning_objectives,
            prerequisites: lesson.prerequisites,
            relatedFeatures: lesson.related_features,
            narrationText: lesson.narration_text,
            estimatedMinutes: lesson.estimated_minutes,
          },
        };

        if (!existing) {
          await prisma.lesson.create({
            data: lessonData,
          });
          created++;
        }
      } catch (error) {
        console.warn(`Failed to import lesson ${lesson.title}: ${(error as Error).message}`);
      }
    }
  }

  console.log(`‚úì Imported ${created} curriculum lessons`);
}

async function importMeasureCommentary() {
  console.log('üìù Importing BWV 846 measure commentary...');

  const data = await readJsonFile<{ measures: any[] }>(
    path.join(CONTENT_DIR, 'commentary', 'bwv-846-complete.json')
  );

  if (!data?.measures) {
    console.log('No commentary data found');
    return;
  }

  // Find BWV 846 prelude and fugue
  const prelude = await prisma.piece.findFirst({
    where: { bwvNumber: 846, type: 'PRELUDE' },
  });

  const fugue = await prisma.piece.findFirst({
    where: { bwvNumber: 846, type: 'FUGUE' },
  });

  let created = 0;

  for (const measureData of data.measures) {
    try {
      const piece = measureData.type === 'fugue' ? fugue : prelude;
      if (!piece) continue;

      // Create or update measure
      const existingMeasure = await prisma.measure.findFirst({
        where: {
          pieceId: piece.id,
          measureNumber: measureData.measure,
        },
      });

      if (!existingMeasure) {
        await prisma.measure.create({
          data: {
            pieceId: piece.id,
            measureNumber: measureData.measure,
            beatCount: 4, // Default for C major
            isPickup: false,
            isFinal: measureData.measure === (measureData.type === 'fugue' ? 27 : 35),
          },
        });
      }

      // Create annotation for the commentary
      await prisma.annotation.create({
        data: {
          pieceId: piece.id,
          measureStart: measureData.measure,
          measureEnd: measureData.measure,
          annotationType: 'PERFORMANCE',
          content: {
            commentary: measureData.commentary,
            harmony: measureData.harmony,
            technicalPoints: measureData.technical_points,
            listeningNotes: measureData.listening_notes,
          },
          displayText: measureData.commentary?.opening || `Measure ${measureData.measure} analysis`,
          voicesInvolved: [],
          source: 'GENERATED',
          verified: true,
        },
      });
      created++;
    } catch (error) {
      console.warn(`Failed to import commentary for measure ${measureData.measure}: ${(error as Error).message}`);
    }
  }

  console.log(`‚úì Imported ${created} measure commentaries`);
}

async function main() {
  console.log('üöÄ Starting content import from generated files...\n');

  try {
    await importPieceIntroductions();
    console.log('');

    await importFeatures();
    console.log('');

    await importCurriculumLessons();
    console.log('');

    await importMeasureCommentary();
    console.log('');

    console.log('‚úÖ Content import completed successfully!');

    // Print summary
    const pieceCount = await prisma.piece.count();
    const featureCount = await prisma.feature.count();
    const lessonCount = await prisma.lesson.count();
    const annotationCount = await prisma.annotation.count();

    console.log('\nüìä Database Summary:');
    console.log(`   Pieces: ${pieceCount}`);
    console.log(`   Features: ${featureCount}`);
    console.log(`   Lessons: ${lessonCount}`);
    console.log(`   Annotations: ${annotationCount}`);
  } catch (error) {
    console.error('‚ùå Error during content import:', error);
    throw error;
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
